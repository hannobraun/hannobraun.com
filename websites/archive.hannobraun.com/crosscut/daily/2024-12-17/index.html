<!DOCTYPE html>
<html lang="en">
    <head>
        <title>Daily Note - 2024-12-17 - Crosscut</title>
        <meta charSet="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link href="/crosscut/style.css" rel="stylesheet">
    </head>
    <body class="max-w-xl mx-auto p-2">
        <header><a href="/crosscut/"><h1>Crosscut</h1></a></header>
        <main>
            <h2>Daily Note - 2024-12-17</h2>
            <div class="m-4 p-4 rounded font-sm bg-slate-200">
                <p class="prose">
                    Hey, I'm Hanno! These are my daily notes on <a
                        href="https://github.com/hannobraun/crosscut"
                        class="text-blue-700 underline font-bold"
                    >Crosscut</a>, the programming language I'm creating. If you
                    have any questions, comments, or feedback, please <a
                        href="mailto:Hanno%20Braun%20%3Chello%40hannobraun.com%3E?subject=&body="
                        class="text-blue-700 underline font-bold"
                    >get in touch</a>!
                </p>
            </div>
            <div class="m-4 p-4 rounded font-sm bg-slate-200">
                <p>
                    This note was published <a
                        href="/crosscut/daily/2024-12-25"
                        class="text-blue-700 underline font-bold"
                    >
                        before Crosscut was called Crosscut</a>! If it refers to
                    "Caterpillar", that is the old name, just so you know.
                </p>
            </div>
            <div class="my-8">
                <nav>
                    <a
                        href="/crosscut/daily"
                        class="text-blue-700 underline font-bold"
                    >< back to list</a>
                </nav>
                <main class="prose">
                    <p>
                        Let's revisit my earlier thought on the problems with
                        <a
                            href="/crosscut/daily/2024-12-12"
                            rel="noopener noreferrer"
                        >ad-hoc effects in Rust</a>, and see how an
                        <a
                            href="/crosscut/daily/2024-12-16"
                            rel="noopener noreferrer"
                        >algebraic effect system</a> can solve those. Here's the
                        initial example again:
                    </p>
                    <pre><code>let name = names().find(|name| name.is_available());</code></pre>
                    <p>
                        Remember, when I changed <code>is_available</code> to be
                        both asynchronous and fallible, that turned into this
                        monstrosity:
                    </p>
                    <pre>
<code>let name = stream::iter(names())
    .filter_map(|name| async move {
        name.is_available()
            .await
            .map(|is_available| is_available.then_some(name))
            .transpose()
    })
    .next()
    .await
    .transpose()?;</code></pre>
                    <p>
                        (Again, I'm not claiming that this is the best way to do
                        it, and my point is not how bad it is. My point is that
                        it's not possible in Rust to write a <code>find</code>
                        function that can be used unchanged, with an
                        asynchronous and/or fallible function argument .)
                    </p>
                    <p>
                        Before we see how algebraic effects can improve on that,
                        let's look at the definition of <code>find</code>. A
                        simplified version could look something like this:
                    </p>
                    <pre>
<code>fn find(&amp;mut self, f: fn(&amp;Self::Item) -&gt; bool)
    -&gt; Option&lt;Self::Item&gt;</code></pre>
                    <p>
                        It takes a function as an argument, uses it to search
                        the iterator that <code>find</code>
                        is defined on, then returns a result, if any.
                    </p>
                    <p>
                        Let's re-imagine that using an algebraic effect system.
                        Here I'm inventing a
                        <code>with</code> syntax that can be used to annotate
                        any function, defining which effects this function has:
                    </p>
                    <pre>
<code>fn find&lt;effects X&gt;(&amp;mut self, f: fn(&amp;Self::Item) -&gt; bool with X)
    -&gt; Option&lt;Self::Item&gt;
    with X</code></pre>
                    <p>
                        I've given <code>find</code> a type parameter called
                        <code>X</code>, which represents any number of
                        (including zero) effects. The new signature states that
                        the function parameter
                        <code>f</code> can have any effect, and that the <code
                        >find</code> function has those same effects (<code>with
                            X</code> on both). So, if <code>f</code> is async,
                        <code>find</code> is async. If <code>f</code> is
                        fallible,
                        <code>find</code> is fallible. But <code>find</code>
                        doesn't have to change to accommodate that.
                    </p>
                    <p>
                        Let's go one step further by leaning more into the
                        effect system. That <code>find</code>
                        might or might not return a value, can also be an
                        effect. Let's call that effect
                        <code>None</code>, because it would be triggered if
                        there's no return value:
                    </p>
                    <pre>
<code>fn find&lt;effects X&gt;(&amp;mut self, f: fn(&amp;Self::Item) -&gt; bool with X) -&gt; Self::Item
    with None, X</code></pre>
                    <p>
                        Now we state that <code>find</code> has the <code
                        >None</code> effect, in addition to any effects that
                        <code>X</code> brings in. I don't know if it would be a
                        good idea to do it this way. I just want to demonstrate
                        what we <em>could</em> do with an effect system.
                    </p>
                    <p>
                        But how does this <code>with</code> syntax help? Well,
                        as a caller, we can now use this single <code
                        >find</code> function in every situation. Whether <code
                        >is_available</code> is asynchronous, fallible, or
                        whatever else; it'll work. Here's how that could look,
                        if <code>f</code> itself had no effects, and we just
                        have to handle the <code>None</code> effect of <code
                        >find</code>:
                    </p>
                    <pre>
<code>let name = try names().find(|name| name.is_available()) {
    None =&gt; {
        "Anonymous"
    }
};</code></pre>
                    <p>
                        I've invented this <code>try</code> syntax for handling
                        effects, inspired by the existing
                        <code>match</code> syntax. If <code>find</code> doesn't
                        find a name (it triggers the <code>None</code> effect),
                        then we fall back to the name "Anonymous".
                    </p>
                    <p>
                        How would that look, if <code>is_available</code> was
                        both asynchronous and fallible? It depends! Is our code
                        in a position to handle these effects, or does it just
                        want to pass them on to its own callers?
                    </p>
                    <pre>
<code>let name = try names().find(|name| name.is_available()) {
    None =&gt; {
        "Anonymous"
    }
    Error(DatabaseError(err)) =&gt; {
        log!("Database error. Retrying...");
            database.reconnect();
            continue; // looks we are in some kind of loop
    }
    // not handling `Async`; some other code up the call stack will do that
};</code></pre>
                    <p>
                        This is a mixed scenario, where our code handles the
                        database error, but not the asynchrony (because it's
                        asynchronous itself). And if our code had all of the
                        combined effects of the code it calls (<code
                        >None</code>, <code>Error</code>, <code>Async</code>),
                        then it wouldn't have to do anything! It would look
                        exactly like it did in the initial example.
                    </p>
                    <p>
                        Would any of this be a good idea for Rust? Maybe; I
                        don't know. I haven't put a lot of thought into that,
                        honestly, because this is not a proposal to improve
                        Rust. This is about demonstrating how algebraic effects
                        can solve a real problem in a real language. Rust is
                        just an example, because it's the language I happen to
                        know best.
                    </p>
                </main>
                <nav class="grid grid-cols-2">
                    <span class="col-1 justify-self-start"><a
                            href="/crosscut/daily/2024-12-16"
                            class="text-blue-700 underline font-bold"
                        ><< previous note</a></span><span
                        class="col-2 justify-self-end"
                    ><a
                            href="/crosscut/daily/2024-12-18"
                            class="text-blue-700 underline font-bold"
                        >next note >></a></span>
                </nav>
            </div>
        </main>
        <hr class="w-1/2 mx-auto my-16">
        <footer class="max-w-fit mx-auto text-sm">
            <p class="max-w-fit mx-auto italic">A website by</p>
            <address>
                <div>
                    Hanno Braun<br>Untere Pfarrgasse 19<br>64720
                    Michelstadt<br>Germany<br>
                </div>
                <div class="my-4">
                    ðŸ“§ <a href="mailto:hello@hannobraun.com"
                    >hello@hannobraun.com</a>
                </div>
            </address>
        </footer>
    </body>
</html>
